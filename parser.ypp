
%{
	#include <stdio.h>
	#include <iostream>
	#include "output.hpp"
	using namespace std;
	using namespace output;
	extern int yylex();
	extern int yylineno;
	void yyerror(const char* message);
%}

%nonassoc ID NUM STRING
%nonassoc VOID INT BYTE BOOL B 
/* %nonassoc VOID INT BYTE BOOL B ENUM */
%nonassoc TRUE FALSE
%nonassoc COMMA SC BREAK CONTINUE

%nonassoc RETURN 
%nonassoc WHILE 

%left IF
%nonassoc WITHOUTELSE
%nonassoc ELSE 

%right ASSIGN
%left OR 
%left AND 
%left EQ
%nonassoc RELOP 
%left PLUSMINUS
%left MULTDIV
%right NOT 
%left LPAREN RPAREN LBRACE RBRACE


%% 
Program :  Funcs {printProductionRule(1);}
;
/* keep as is  */
Funcs : %empty {printProductionRule(2);}
		|FuncDecl Funcs {printProductionRule(3);}
;
/* keep as is */
FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {printProductionRule(4);} 
;


/* keep as is */
RetType : Type {printProductionRule(8);}
		| VOID {printProductionRule(9);}
;

/* keep as is */
Formals : %empty {printProductionRule(10);}
		| FormalsList {printProductionRule(11);}
;

/* keep as is */
FormalsList : FormalDecl {printProductionRule(12);}
		| FormalDecl COMMA FormalsList {printProductionRule(13);}
;

FormalDecl : Type ID {printProductionRule(14);}
;


/* keep as is */
Statements : Statement {printProductionRule(19);}
		| Statements Statement {printProductionRule(20);}
;
/* modify */
Statement : LBRACE Statements RBRACE {printProductionRule(21);}
		| Type ID SC {printProductionRule(22);}
		| Type ID ASSIGN Exp SC {printProductionRule(25);}
		| ID ASSIGN Exp SC {printProductionRule(27);}
		| Call SC {printProductionRule(28);}
		| RETURN SC {printProductionRule(29);}
		| RETURN Exp SC {printProductionRule(30);}
		| IF LPAREN Exp RPAREN Statement %prec WITHOUTELSE {printProductionRule(31);}
		| IF LPAREN Exp RPAREN Statement ELSE Statement {printProductionRule(32);}
		| WHILE LPAREN Exp RPAREN Statement {printProductionRule(33);}
		| BREAK SC {printProductionRule(34);}
		| CONTINUE SC {printProductionRule(35);}
;

/* keep as is */
Call : ID LPAREN ExpList RPAREN {printProductionRule(36);}
		| ID LPAREN RPAREN {printProductionRule(37);}
;

/* keep as is */
ExpList : Exp {printProductionRule(38);}
		| Exp COMMA ExpList {printProductionRule(39);}
;

/* keep as is */
Type : INT {printProductionRule(40);}
		| BYTE {printProductionRule(41);}
		| BOOL {printProductionRule(42);}
;


/* modify */
Exp : LPAREN Exp RPAREN {printProductionRule(44);}
		| Exp PLUSMINUS Exp {printProductionRule(45);}
		| Exp MULTDIV Exp {printProductionRule(45);}
		| ID {printProductionRule(46);}
		| Call {printProductionRule(47);}
		| NUM {printProductionRule(48);}
		| NUM B {printProductionRule(49);}
		| STRING {printProductionRule(50);}
		| TRUE {printProductionRule(51);}
		| FALSE {printProductionRule(52);}
		| NOT Exp {printProductionRule(53);}
		| Exp AND Exp {printProductionRule(54);}
		| Exp OR Exp {printProductionRule(55);}
		| Exp RELOP Exp {printProductionRule(56);}
		| Exp EQ Exp {printProductionRule(56);}
		| LPAREN Type RPAREN Exp {printProductionRule(57);}
;
		


%%

void yyerror(const char*){
	errorSyn(yylineno);
}

int main ()
{
	yyparse();
}
