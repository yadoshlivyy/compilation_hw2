
%{
	#include <stdio.h>
	#include <iostream>
	#include "output.hpp"
	using namespace std;
	using namespace output;
	extern int yylex();
	extern int yylineno;
	void yyerror(const char* message);
%}

%nonassoc ID NUM STRING
%nonassoc VOID INT BYTE BOOL B ENUM
%nonassoc TRUE FALSE
%nonassoc COMMA SC BREAK CONTINUE

%nonassoc RETURN 
%nonassoc WHILE 

%left IF
%nonassoc WITHOUTELSE
%nonassoc ELSE 

%right ASSIGN
%left OR 
%left AND 
%left EQ
%nonassoc RELOP 
%left PLUSMINUS
%left MULTDIV
%right NOT 
%left LPAREN RPAREN LBRACE RBRACE


%% 

Program : Enums Funcs {printProductionRule(1);}
;

Funcs : %empty {printProductionRule(2);}
		|FuncDecl Funcs {printProductionRule(3);}
;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {printProductionRule(4);} 
;

Enums : %empty		{printProductionRule(5);}
		| EnumDecl Enums {printProductionRule(6);}
;

EnumDecl : ENUM ID LBRACE EnumeratorList RBRACE SC {printProductionRule(7);}		
;

RetType : Type {printProductionRule(8);}
		| VOID {printProductionRule(9);}
;

Formals : %empty {printProductionRule(10);}
		| FormalsList {printProductionRule(11);}
;

FormalsList : FormalDecl {printProductionRule(12);}
		| FormalDecl COMMA FormalsList {printProductionRule(13);}
;

FormalDecl : Type ID {printProductionRule(14);}
		| EnumType ID {printProductionRule(15);}
;

EnumeratorList : Enumerator {printProductionRule(16);}
		| EnumeratorList COMMA Enumerator {printProductionRule(17);}
;

Enumerator : ID {printProductionRule(18);}
;

Statements : Statement {printProductionRule(19);}
		| Statements Statement {printProductionRule(20);}
;

Statement : LBRACE Statements RBRACE {printProductionRule(21);}
		| Type ID SC {printProductionRule(22);}
		| EnumType ID SC {printProductionRule(23);}
		| EnumDecl {printProductionRule(24);}
		| Type ID ASSIGN Exp SC {printProductionRule(25);}
		| EnumType ID ASSIGN Exp SC {printProductionRule(26);}
		| ID ASSIGN Exp SC {printProductionRule(27);}
		| Call SC {printProductionRule(28);}
		| RETURN SC {printProductionRule(29);}
		| RETURN Exp SC {printProductionRule(30);}
		| IF LPAREN Exp RPAREN Statement %prec WITHOUTELSE {printProductionRule(31);}
		| IF LPAREN Exp RPAREN Statement ELSE Statement {printProductionRule(32);}
		| WHILE LPAREN Exp RPAREN Statement {printProductionRule(33);}
		| BREAK SC {printProductionRule(34);}
		| CONTINUE SC {printProductionRule(35);}
;

Call : ID LPAREN ExpList RPAREN {printProductionRule(36);}
		| ID LPAREN RPAREN {printProductionRule(37);}
;

ExpList : Exp {printProductionRule(38);}
		| Exp COMMA ExpList {printProductionRule(39);}
;

Type : INT {printProductionRule(40);}
		| BYTE {printProductionRule(41);}
		| BOOL {printProductionRule(42);}
;

EnumType : ENUM ID {printProductionRule(43);}
;

Exp : LPAREN Exp RPAREN {printProductionRule(44);}
		| Exp PLUSMINUS Exp {printProductionRule(45);}
		| Exp MULTDIV Exp {printProductionRule(45);}
		| ID {printProductionRule(46);}
		| Call {printProductionRule(47);}
		| NUM {printProductionRule(48);}
		| NUM B {printProductionRule(49);}
		| STRING {printProductionRule(50);}
		| TRUE {printProductionRule(51);}
		| FALSE {printProductionRule(52);}
		| NOT Exp {printProductionRule(53);}
		| Exp AND Exp {printProductionRule(54);}
		| Exp OR Exp {printProductionRule(55);}
		| Exp RELOP Exp {printProductionRule(56);}
		| Exp EQ Exp {printProductionRule(56);}
		| LPAREN Type RPAREN Exp {printProductionRule(57);}
;
		


%%

void yyerror(const char*){
	errorSyn(yylineno);
}

int main ()
{
	yyparse();
}
