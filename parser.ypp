
%{
	#include <stdio.h>
	#include <iostream>
	#include "output.hpp"
	using namespace std;
	using namespace output;
	extern int yylex();
	extern int yylineno;
	void yyerror(const char* message);
%}

%nonassoc ID NUM STRING
%nonassoc VOID INT BYTE BOOL B CONST 
/* %nonassoc VOID INT BYTE BOOL B ENUM */
%nonassoc TRUE FALSE
%nonassoc COMMA SC BREAK CONTINUE

%nonassoc RETURN 
%nonassoc WHILE 

%left IF
%nonassoc WITHOUTELSE
%nonassoc ELSE 

%right ASSIGN
%left OR 
%left AND 
%left EQ
%nonassoc RELOP 
%left PLUSMINUS
%left MULTDIV
%right NOT 
%left LPAREN RPAREN LBRACE RBRACE


%% 
Program :  Funcs {printProductionRule(1);}
;
Funcs : %empty {printProductionRule(2);}
		|FuncDecl Funcs {printProductionRule(3);}
;
FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {printProductionRule(4);} 
;
RetType : Type {printProductionRule(5);}
		| VOID {printProductionRule(6);}
;

Formals : %empty {printProductionRule(7);}
		| FormalsList {printProductionRule(8);}
;

FormalsList : FormalDecl {printProductionRule(9);}
		| FormalDecl COMMA FormalsList {printProductionRule(10);}
;

FormalDecl : Type ID {printProductionRule(11);}
;
Statements : Statement {printProductionRule(12);}
		| Statements Statement {printProductionRule(13);}
;
Statement : LBRACE Statements RBRACE {printProductionRule(14);}
		| TypeAnnotation Type ID SC {printProductionRule(15);}
		| TypeAnnotation Type ID ASSIGN Exp SC {printProductionRule(16);}
		| ID ASSIGN Exp SC {printProductionRule(17);}
		| Call SC {printProductionRule(18);}
		| RETURN SC {printProductionRule(19);}
		| RETURN Exp SC {printProductionRule(20);}
		| IF LPAREN Exp RPAREN Statement %prec WITHOUTELSE {printProductionRule(21);}
		| IF LPAREN Exp RPAREN Statement ELSE Statement {printProductionRule(22);}
		| WHILE LPAREN Exp RPAREN Statement {printProductionRule(23);}
		| BREAK SC {printProductionRule(24);}
		| CONTINUE SC {printProductionRule(25);}
;
Call : ID LPAREN ExpList RPAREN {printProductionRule(26);}
		| ID LPAREN RPAREN {printProductionRule(27);}
;
ExpList : Exp {printProductionRule(28);}
		| Exp COMMA ExpList {printProductionRule(29);}
;
Type : INT {printProductionRule(30);}
		| BYTE {printProductionRule(31);}
		| BOOL {printProductionRule(32);}
;
TypeAnnotation : %empty {printProductionRule(33)}
			   | CONST {printProductionRule(34)}
;
/* modify */
Exp : LPAREN Exp RPAREN {printProductionRule(35);}
		/* | Exp BINOP Exp {printProductionRule(36)} */
		/* critical non compiled code upwards */
		/* | Exp PLUSMINUS Exp {printProductionRule(45);}
		| Exp MULTDIV Exp {printProductionRule(45);} */
		| ID {printProductionRule(37);}
		| Call {printProductionRule(38);}
		| NUM {printProductionRule(39);}
		| NUM B {printProductionRule(40);}
		| STRING {printProductionRule(41);}
		| TRUE {printProductionRule(42);}
		| FALSE {printProductionRule(43);}
		| NOT Exp {printProductionRule(44);}
		| Exp AND Exp {printProductionRule(45);}
		| Exp OR Exp {printProductionRule(46);}
		| Exp RELOP Exp {printProductionRule(47);}
		/* | Exp EQ Exp {printProductionRule(47);} */
		/* critical non compiled code here upwards */
		| LPAREN TypeAnnotation Type RPAREN Exp {printProductionRule(48);}
;
		


%%

void yyerror(const char*){
	errorSyn(yylineno);
}

int main ()
{
	yyparse();
}
